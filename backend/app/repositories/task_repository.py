"""\nTask Repository for MySQL-based persistence.\n\nThis module provides a TaskRepository class that handles CRUD operations\nfor tasks with MySQL database persistence.\n\"\"\"\n\nimport os\nfrom contextlib import contextmanager\nfrom typing import List, Optional\n\nimport mysql.connector\nfrom mysql.connector import Error\n\nfrom app.models.task import Task, TaskCreate, TaskUpdate\n\n\nclass TaskRepository:\n    \"\"\"\n    Repository for managing task persistence with MySQL database.\n\n    Handles database connections, table initialization, and CRUD operations.\n    Uses environment variables for database configuration.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the task repository.\n        Reads database configuration from environment variables.\n        \"\"\"\n        self.db_config = {\n            \"host\": os.getenv(\"DB_HOST\", \"localhost\"),\n            \"port\": int(os.getenv(\"DB_PORT\", \"3306\")),\n            \"user\": os.getenv(\"DB_USER\", \"taskuser\"),\n            \"password\": os.getenv(\"DB_PASSWORD\", \"taskpassword\"),\n            \"database\": os.getenv(\"DB_NAME\", \"taskmanager\"),\n        }\n        self._initialize_database()\n\n    @contextmanager\n    def _get_connection(self):\n        \"\"\"\n        Context manager for database connections.\n        Ensures connections are properly closed after use.\n\n        Yields:\n            MySQL connection object\n        \"\"\"\n        connection = None\n        try:\n            connection = mysql.connector.connect(**self.db_config)\n            yield connection\n        except Error as e:\n            print(f\"Database connection error: {e}\")\n            raise\n        finally:\n            if connection and connection.is_connected():\n                connection.close()\n\n    def _initialize_database(self) -> None:\n        \"\"\"\n        Initialize the database schema.\n        Creates the tasks table if it doesn't exist.\n        \"\"\"\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS tasks (\n            id VARCHAR(36) PRIMARY KEY,\n            title VARCHAR(200) NOT NULL,\n            description TEXT,\n            completed BOOLEAN DEFAULT FALSE,\n            created_at VARCHAR(30) NOT NULL,\n            updated_at VARCHAR(30) NOT NULL\n        )\n        \"\"\"\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor()\n                cursor.execute(create_table_query)\n                connection.commit()\n                cursor.close()\n        except Error as e:\n            print(f\"Error initializing database: {e}\")\n            raise\n\n    def get_all(self) -> List[Task]:\n        \"\"\"\n        Retrieve all tasks.\n\n        Returns:\n            List of all tasks, ordered by creation date (newest first)\n        \"\"\"\n        query = (\n            \"SELECT id, title, description, completed, created_at, updated_at \"\n            \"FROM tasks ORDER BY created_at DESC\"\n        )\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor(dictionary=True)\n                cursor.execute(query)\n                results = cursor.fetchall()\n                cursor.close()\n\n                return [Task(**row) for row in results]\n        except Error as e:\n            print(f\"Error retrieving all tasks: {e}\")\n            raise\n\n    def get_by_id(self, task_id: str) -> Optional[Task]:\n        \"\"\"\n        Retrieve a single task by ID.\n\n        Args:\n            task_id: The unique identifier of the task\n\n        Returns:\n            Task object if found, None otherwise\n        \"\"\"\n        query = (\n            \"SELECT id, title, description, completed, created_at, updated_at \"\n            \"FROM tasks WHERE id = %s\"\n        )\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor(dictionary=True)\n                cursor.execute(query, (task_id,))\n                result = cursor.fetchone()\n                cursor.close()\n\n                if result:\n                    return Task(**result)\n                return None\n        except Error as e:\n            print(f\"Error retrieving task {task_id}: {e}\")\n            raise\n\n    def create(self, task_data: TaskCreate) -> Task:\n        \"\"\"\n        Create a new task and persist it.\n\n        Args:\n            task_data: TaskCreate object with title and description\n\n        Returns:\n            The newly created Task object\n        \"\"\"\n        task = Task.create_new(task_data)\n\n        query = \"\"\"\n        INSERT INTO tasks (id, title, description, completed, created_at, updated_at)\n        VALUES (%s, %s, %s, %s, %s, %s)\n        \"\"\"\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor()\n                cursor.execute(\n                    query,\n                    (\n                        task.id,\n                        task.title,\n                        task.description,\n                        task.completed,\n                        task.created_at,\n                        task.updated_at,\n                    ),\n                )\n                connection.commit()\n                cursor.close()\n\n                return task\n        except Error as e:\n            print(f\"Error creating task: {e}\")\n            raise\n\n    def update(self, task_id: str, task_data: TaskUpdate) -> Optional[Task]:\n        \"\"\"\n        Update an existing task and persist the changes.\n\n        Args:\n            task_id: The unique identifier of the task to update\n            task_data: TaskUpdate object with fields to update\n\n        Returns:\n            Updated Task object if found, None otherwise\n        \"\"\"\n        existing_task = self.get_by_id(task_id)\n        if existing_task is None:\n            return None\n\n        updated_task = existing_task.update_from(task_data)\n\n        query = \"\"\"\n        UPDATE tasks\n        SET title = %s, description = %s, completed = %s, updated_at = %s\n        WHERE id = %s\n        \"\"\"\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor()\n                cursor.execute(\n                    query,\n                    (\n                        updated_task.title,\n                        updated_task.description,\n                        updated_task.completed,\n                        updated_task.updated_at,\n                        task_id,\n                    ),\n                )\n                connection.commit()\n                cursor.close()\n\n                return updated_task\n        except Error as e:\n            print(f\"Error updating task {task_id}: {e}\")\n            raise\n\n    def delete(self, task_id: str) -> bool:\n        \"\"\"\n        Delete a task and persist the change.\n\n        Args:\n            task_id: The unique identifier of the task to delete\n\n        Returns:\n            True if task was deleted, False if task was not found\n        \"\"\"\n        query = \"DELETE FROM tasks WHERE id = %s\"\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor()\n                cursor.execute(query, (task_id,))\n                rows_affected = cursor.rowcount\n                connection.commit()\n                cursor.close()\n\n                return rows_affected > 0\n        except Error as e:\n            print(f\"Error deleting task {task_id}: {e}\")\n            raise\n\n    def delete_all(self) -> int:\n        \"\"\"\n        Delete all tasks from the database.\n\n        Returns:\n            Number of tasks deleted\n        \"\"\"\n        query = \"DELETE FROM tasks\"\n\n        try:\n            with self._get_connection() as connection:\n                cursor = connection.cursor()\n                cursor.execute(query)\n                rows_affected = cursor.rowcount\n                connection.commit()\n                cursor.close()\n\n                return rows_affected\n        except Error as e:\n            print(f\"Error deleting all tasks: {e}\")\n            raise\n