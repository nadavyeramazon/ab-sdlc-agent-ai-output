"""\nComprehensive backend tests for FastAPI application.\n\nThis test suite covers:\n- /api/hello endpoint (GET)\n- /health endpoint (GET)\n- Response validation\n- Status codes\n- JSON structure\n- Edge cases and error scenarios\n"""\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom datetime import datetime\nfrom main import app\n\n\n# Test client fixture\n@pytest.fixture\ndef client():\n    """\n    Create a TestClient instance for testing FastAPI endpoints.\n    This fixture is reused across all tests.\n    """\n    import tempfile\n    import os\n    from task_repository import TaskRepository\n    \n    # Create a temporary directory for test data\n    temp_dir = tempfile.mkdtemp()\n    test_data_file = os.path.join(temp_dir, "test_tasks.json")\n    \n    # Override the repository with test data file\n    import main\n    main._task_repository = TaskRepository(data_file=test_data_file)\n    \n    client = TestClient(app)\n    \n    yield client\n    \n    # Cleanup\n    import shutil\n    shutil.rmtree(temp_dir, ignore_errors=True)\n    main._task_repository = None\n\n\nclass TestHealthEndpoint:\n    """Test suite for /health endpoint"""\n\n    def test_health_endpoint_success(self, client):\n        """Test successful response from /health endpoint"""\n        response = client.get("/health")\n        \n        assert response.status_code == 200\n        assert response.headers["content-type"] == "application/json"\n\n    def test_health_endpoint_status_code(self, client):\n        """Test that /health returns 200 status code"""\n        response = client.get("/health")\n        \n        assert response.status_code == 200\n\n    def test_health_endpoint_json_structure(self, client):\n        """Test that /health returns correct JSON structure"""\n        response = client.get("/health")\n        data = response.json()\n        \n        # Verify required key is present\n        assert "status" in data\n        \n        # Verify it only contains the status key\n        assert len(data) == 1\n\n    def test_health_endpoint_status_value(self, client):\n        """Test that /health returns 'healthy' status"""\n        response = client.get("/health")\n        data = response.json()\n        \n        assert data["status"] == "healthy"\n        assert isinstance(data["status"], str)\n\n    def test_health_endpoint_multiple_calls(self, client):\n        """Test that multiple calls to /health are consistent"""\n        for _ in range(5):\n            response = client.get("/health")\n            data = response.json()\n            \n            assert response.status_code == 200\n            assert data["status"] == "healthy"\n\n    def test_health_endpoint_with_trailing_slash(self, client):\n        """Test /health endpoint with trailing slash (should fail as not defined)"""\n        response = client.get("/health/")\n        \n        # FastAPI by default doesn't redirect, so this should return 404\n        assert response.status_code == 404\n\n    def test_health_endpoint_wrong_method_post(self, client):\n        """Test that POST method is not allowed on /health"""\n        response = client.post("/health")\n        \n        # Should return 405 Method Not Allowed\n        assert response.status_code == 405\n\n    def test_health_endpoint_wrong_method_put(self, client):\n        """Test that PUT method is not allowed on /health"""\n        response = client.put("/health")\n        \n        # Should return 405 Method Not Allowed\n        assert response.status_code == 405\n\n    def test_health_endpoint_wrong_method_delete(self, client):\n        """Test that DELETE method is not allowed on /health"""\n        response = client.delete("/health")\n        \n        # Should return 405 Method Not Allowed\n        assert response.status_code == 405\n\n    def test_health_endpoint_case_sensitivity(self, client):\n        """Test that endpoint is case-sensitive"""\n        response = client.get("/HEALTH")\n        \n        # Should return 404 as endpoint is case-sensitive\n        assert response.status_code == 404\n\n\nclass TestCORSConfiguration:\n    """Test suite for CORS middleware configuration"""\n\n    def test_cors_headers_present(self, client):\n        """Test that CORS headers are present in responses"""\n        response = client.get("/api/tasks", headers={"Origin": "http://localhost:3000"})\n        \n        # CORS headers should be present\n        assert "access-control-allow-origin" in response.headers\n\n    def test_cors_allows_frontend_origin(self, client):\n        """Test that CORS allows requests from frontend origin"""\n        response = client.get(\n            "/api/tasks",\n            headers={"Origin": "http://localhost:3000"}\n        )\n        \n        assert response.status_code == 200\n        assert response.headers.get("access-control-allow-origin") == "http://localhost:3000"\n\n\nclass TestApplicationRoutes:\n    """Test suite for general application routing"""\n\n    def test_nonexistent_route_returns_404(self, client):\n        """Test that accessing non-existent route returns 404"""\n        response = client.get("/nonexistent")\n        \n        assert response.status_code == 404\n\n    def test_root_path_returns_404(self, client):\n        """Test that root path returns 404 (no root endpoint defined)"""\n        response = client.get("/")\n        \n        assert response.status_code == 404\n\n    def test_api_prefix_without_endpoint(self, client):\n        """Test that /api without endpoint returns 404"""\n        response = client.get("/api")\n        \n        assert response.status_code == 404\n\n    def test_api_prefix_with_trailing_slash(self, client):\n        """Test that /api/ without endpoint returns 404"""\n        response = client.get("/api/")\n        \n        assert response.status_code == 404\n\n\nclass TestResponseHeaders:\n    """Test suite for HTTP response headers"""\n\n    def test_health_endpoint_content_type(self, client):\n        """Test that /health returns correct content-type header"""\n        response = client.get("/health")\n        \n        assert response.headers["content-type"] == "application/json"\n\n    def test_tasks_endpoint_content_type(self, client):\n        """Test that /api/tasks returns correct content-type header"""\n        response = client.get("/api/tasks")\n        \n        assert response.headers["content-type"] == "application/json"\n\n\nclass TestEdgeCases:\n    """Test suite for edge cases and boundary conditions"""\n\n    def test_health_endpoint_with_query_params(self, client):\n        """Test /health with query parameters (should be ignored)"""\n        response = client.get("/health?test=true")\n        \n        # Should still work normally, query params ignored\n        assert response.status_code == 200\n        data = response.json()\n        assert data["status"] == "healthy"\n\n    def test_concurrent_requests_to_health(self, client):\n        """Test multiple concurrent requests to /health"""\n        responses = []\n        \n        # Make 10 concurrent-like requests\n        for _ in range(10):\n            response = client.get("/health")\n            responses.append(response)\n        \n        # All should succeed\n        for response in responses:\n            assert response.status_code == 200\n            data = response.json()\n            assert data["status"] == "healthy"\n\n\n# Property-Based Tests\nfrom hypothesis import given, strategies as st\nfrom hypothesis import settings, HealthCheck\n\n\nclass TestTaskCreationProperties:\n    """Property-based tests for task creation"""\n\n    @given(st.text().filter(lambda s: not s or not s.strip()))\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_empty_title_rejection(self, client, empty_title):\n        """\n        **Feature: task-manager-app, Property 2: Empty title rejection**\n        **Validates: Requirements 1.2**\n        \n        For any string composed entirely of whitespace or empty string,\n        attempting to create a task with that title should result in a\n        validation error (422 status), and the task list should remain unchanged.\n        """\n        # Get initial task count\n        initial_response = client.get("/api/tasks")\n        initial_tasks = initial_response.json()["tasks"]\n        initial_count = len(initial_tasks)\n        \n        # Attempt to create task with empty/whitespace title\n        response = client.post("/api/tasks", json={\n            "title": empty_title,\n            "description": "Test description"\n        })\n        \n        # Should return validation error\n        assert response.status_code == 422\n        \n        # Task list should remain unchanged\n        after_response = client.get("/api/tasks")\n        after_tasks = after_response.json()["tasks"]\n        assert len(after_tasks) == initial_count\n\n    @given(st.lists(\n        st.tuples(\n            st.text(min_size=1).filter(lambda s: s.strip()),  # title (non-empty)\n            st.text(max_size=1000)  # description\n        ),\n        min_size=0,\n        max_size=10\n    ))\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_task_retrieval_completeness(self, client, task_data_list):\n        """\n        **Feature: task-manager-app, Property 3: Task retrieval completeness**\n        **Validates: Requirements 2.1**\n        \n        For any set of tasks in storage, when retrieving all tasks via GET /api/tasks,\n        the response should contain exactly the same tasks that exist in storage\n        with no additions or omissions.\n        """\n        # Clear all existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Create all tasks\n        created_task_ids = set()\n        for title, description in task_data_list:\n            response = client.post("/api/tasks", json={\n                "title": title.strip(),\n                "description": description\n            })\n            if response.status_code == 201:\n                task = response.json()\n                created_task_ids.add(task["id"])\n        \n        # Retrieve all tasks\n        response = client.get("/api/tasks")\n        assert response.status_code == 200\n        \n        retrieved_tasks = response.json()["tasks"]\n        retrieved_task_ids = {task["id"] for task in retrieved_tasks}\n        \n        # Verify all created tasks are retrieved\n        assert created_task_ids == retrieved_task_ids\n        \n        # Verify count matches\n        assert len(retrieved_tasks) == len(created_task_ids)\n\n    @given(\n        st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),  # valid title (max 200 chars)\n        st.text(max_size=1000)  # description\n    )\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_restful_status_codes(self, client, title, description):\n        """\n        **Feature: task-manager-app, Property 8: RESTful status codes**\n        **Validates: Requirements 6.2, 6.3, 6.4, 6.5**\n        \n        For any API operation, successful creates should return 201, successful updates/gets\n        should return 200, successful deletes should return 204, validation errors should\n        return 422, and not-found errors should return 404.\n        """\n        # Clear existing tasks\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Test POST returns 201 for successful create\n        create_response = client.post("/api/tasks", json={\n            "title": title.strip(),\n            "description": description\n        })\n        assert create_response.status_code == 201\n        task_id = create_response.json()["id"]\n        \n        # Test GET returns 200 for successful retrieval\n        get_response = client.get(f"/api/tasks/{task_id}")\n        assert get_response.status_code == 200\n        \n        # Test PUT returns 200 for successful update\n        update_response = client.put(f"/api/tasks/{task_id}", json={\n            "title": "Updated " + title.strip()[:50],\n            "completed": True\n        })\n        assert update_response.status_code == 200\n        \n        # Test DELETE returns 204 for successful delete\n        delete_response = client.delete(f"/api/tasks/{task_id}")\n        assert delete_response.status_code == 204\n        \n        # Test GET returns 404 for non-existent task\n        not_found_response = client.get(f"/api/tasks/{task_id}")\n        assert not_found_response.status_code == 404\n        \n        # Test PUT returns 404 for non-existent task\n        update_not_found = client.put(f"/api/tasks/{task_id}", json={"title": "Test"})\n        assert update_not_found.status_code == 404\n        \n        # Test DELETE returns 404 for non-existent task\n        delete_not_found = client.delete(f"/api/tasks/{task_id}")\n        assert delete_not_found.status_code == 404\n        \n        # Test POST returns 422 for validation error (empty title)\n        validation_error = client.post("/api/tasks", json={\n            "title": "",\n            "description": "Test"\n        })\n        assert validation_error.status_code == 422\n        \n        # Test PUT returns 422 for validation error (empty title)\n        # First create a task to update\n        create_response2 = client.post("/api/tasks", json={\n            "title": "Valid Title",\n            "description": "Test"\n        })\n        task_id2 = create_response2.json()["id"]\n        \n        update_validation_error = client.put(f"/api/tasks/{task_id2}", json={\n            "title": "   ",  # whitespace only\n            "description": "Test"\n        })\n        assert update_validation_error.status_code == 422\n\n    @given(st.text().filter(lambda s: not s or not s.strip()))\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_invalid_update_rejection(self, client, invalid_title):\n        """\n        **Feature: task-manager-app, Property 7: Invalid update rejection**\n        **Validates: Requirements 5.3**\n        \n        For any task update request with an empty or whitespace-only title,\n        the API should reject the request with a validation error (422 status),\n        and the task should remain unchanged in storage.\n        """\n        # Clear existing tasks\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Create a task to update\n        create_response = client.post("/api/tasks", json={\n            "title": "Original Title",\n            "description": "Original Description"\n        })\n        assert create_response.status_code == 201\n        task = create_response.json()\n        task_id = task["id"]\n        original_title = task["title"]\n        original_description = task["description"]\n        original_updated_at = task["updated_at"]\n        \n        # Attempt to update with invalid title\n        update_response = client.put(f"/api/tasks/{task_id}", json={\n            "title": invalid_title,\n            "description": "New Description"\n        })\n        \n        # Should return validation error\n        assert update_response.status_code == 422\n        \n        # Task should remain unchanged\n        get_response = client.get(f"/api/tasks/{task_id}")\n        assert get_response.status_code == 200\n        unchanged_task = get_response.json()\n        \n        assert unchanged_task["title"] == original_title\n        assert unchanged_task["description"] == original_description\n        assert unchanged_task["updated_at"] == original_updated_at\n\n    @given(st.lists(\n        st.tuples(\n            st.text(min_size=1).filter(lambda s: s.strip()),  # title (non-empty)\n            st.text(max_size=1000)  # description\n        ),\n        min_size=2,\n        max_size=10\n    ))\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_task_ordering_consistency(self, client, task_data_list):\n        """\n        **Feature: task-manager-app, Property 10: Task ordering consistency**\n        **Validates: Requirements 2.4**\n        \n        For any set of tasks, when retrieved via GET /api/tasks, the tasks should be\n        ordered by creation timestamp in descending order (newest first).\n        """\n        import time\n        \n        # Clear all existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Create tasks with small delays to ensure different timestamps\n        created_tasks = []\n        for title, description in task_data_list:\n            response = client.post("/api/tasks", json={\n                "title": title.strip(),\n                "description": description\n            })\n            if response.status_code == 201:\n                task = response.json()\n                created_tasks.append(task)\n                time.sleep(0.01)  # Small delay to ensure different timestamps\n        \n        # Retrieve all tasks\n        response = client.get("/api/tasks")\n        assert response.status_code == 200\n        \n        retrieved_tasks = response.json()["tasks"]\n        \n        # Verify tasks are ordered by creation timestamp (newest first)\n        if len(retrieved_tasks) > 1:\n            for i in range(len(retrieved_tasks) - 1):\n                current_timestamp = retrieved_tasks[i]["created_at"]\n                next_timestamp = retrieved_tasks[i + 1]["created_at"]\n                \n                # Current task should have a timestamp >= next task (descending order)\n                assert current_timestamp >= next_timestamp, \\\n                    f"Tasks not in descending order: {current_timestamp} should be >= {next_timestamp}"\n\n    @given(\n        st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),  # valid title (max 200 chars)\n        st.text(max_size=1000),  # description\n        st.booleans()  # initial completion status\n    )\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_completion_toggle_idempotence(self, client, title, description, initial_completed):\n        """\n        **Feature: task-manager-app, Property 4: Completion toggle idempotence**\n        **Validates: Requirements 3.1, 3.3**\n        \n        For any task, toggling its completion status twice should return it to its\n        original state, and the persisted data should reflect this final state.\n        """\n        # Clear all existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Ensure title doesn't exceed 200 chars after stripping\n        trimmed_title = title.strip()[:200]\n        \n        # Create a task with initial completion status\n        create_response = client.post("/api/tasks", json={\n            "title": trimmed_title,\n            "description": description\n        })\n        assert create_response.status_code == 201\n        task = create_response.json()\n        task_id = task["id"]\n        \n        # Set initial completion status if different from default (False)\n        if initial_completed:\n            update_response = client.put(f"/api/tasks/{task_id}", json={\n                "completed": initial_completed\n            })\n            assert update_response.status_code == 200\n        \n        # Get the task to confirm initial state\n        get_response = client.get(f"/api/tasks/{task_id}")\n        assert get_response.status_code == 200\n        initial_task = get_response.json()\n        initial_status = initial_task["completed"]\n        \n        # Toggle completion status (first toggle)\n        toggle1_response = client.put(f"/api/tasks/{task_id}", json={\n            "completed": not initial_status\n        })\n        assert toggle1_response.status_code == 200\n        toggled_task = toggle1_response.json()\n        assert toggled_task["completed"] == (not initial_status)\n        \n        # Toggle completion status again (second toggle)\n        toggle2_response = client.put(f"/api/tasks/{task_id}", json={\n            "completed": initial_status\n        })\n        assert toggle2_response.status_code == 200\n        final_task = toggle2_response.json()\n        \n        # Verify task is back to original state\n        assert final_task["completed"] == initial_status\n        \n        # Verify persistence by retrieving the task again\n        verify_response = client.get(f"/api/tasks/{task_id}")\n        assert verify_response.status_code == 200\n        persisted_task = verify_response.json()\n        assert persisted_task["completed"] == initial_status\n        \n        # Verify other fields remain unchanged\n        assert persisted_task["id"] == task_id\n        assert persisted_task["title"] == trimmed_title\n        assert persisted_task["description"] == description\n\n    @given(\n        st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),  # valid title (max 200 chars)\n        st.text(max_size=1000)  # description\n    )\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_delete_operation_removes_task(self, client, title, description):\n        """\n        **Feature: task-manager-app, Property 5: Delete operation removes task**\n        **Validates: Requirements 4.1, 4.2**\n        \n        For any existing task, when a delete operation succeeds (204 status),\n        subsequent attempts to retrieve that specific task should return 404,\n        and the task should not appear in the list of all tasks.\n        """\n        # Clear all existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Ensure title doesn't exceed 200 chars after stripping\n        trimmed_title = title.strip()[:200]\n        \n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": trimmed_title,\n            "description": description\n        })\n        assert create_response.status_code == 201\n        task = create_response.json()\n        task_id = task["id"]\n        \n        # Verify task exists before deletion\n        get_before_response = client.get(f"/api/tasks/{task_id}")\n        assert get_before_response.status_code == 200\n        \n        # Verify task appears in the list\n        list_before_response = client.get("/api/tasks")\n        assert list_before_response.status_code == 200\n        tasks_before = list_before_response.json()["tasks"]\n        task_ids_before = {t["id"] for t in tasks_before}\n        assert task_id in task_ids_before\n        \n        # Delete the task\n        delete_response = client.delete(f"/api/tasks/{task_id}")\n        assert delete_response.status_code == 204\n        \n        # Verify task no longer exists (GET should return 404)\n        get_after_response = client.get(f"/api/tasks/{task_id}")\n        assert get_after_response.status_code == 404\n        \n        # Verify task does not appear in the list\n        list_after_response = client.get("/api/tasks")\n        assert list_after_response.status_code == 200\n        tasks_after = list_after_response.json()["tasks"]\n        task_ids_after = {t["id"] for t in tasks_after}\n        assert task_id not in task_ids_after\n        \n        # Verify attempting to delete again returns 404\n        delete_again_response = client.delete(f"/api/tasks/{task_id}")\n        assert delete_again_response.status_code == 404\n\n\n\nclass TestTaskAPIEndpoints:\n    """Unit tests for task API endpoints"""\n\n    def test_get_all_tasks_empty_list(self, client):\n        """Test GET /api/tasks with empty task list"""\n        # Clear all tasks\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        response = client.get("/api/tasks")\n        assert response.status_code == 200\n        data = response.json()\n        assert "tasks" in data\n        assert data["tasks"] == []\n\n    def test_get_all_tasks_populated_list(self, client):\n        """Test GET /api/tasks with populated task list"""\n        # Clear all tasks\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Create some tasks\n        task1 = client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        task2 = client.post("/api/tasks", json={"title": "Task 2", "description": "Desc 2"})\n        \n        response = client.get("/api/tasks")\n        assert response.status_code == 200\n        data = response.json()\n        assert "tasks" in data\n        assert len(data["tasks"]) == 2\n\n    def test_post_task_valid_data(self, client):\n        """Test POST /api/tasks with valid data"""\n        response = client.post("/api/tasks", json={\n            "title": "New Task",\n            "description": "Task description"\n        })\n        \n        assert response.status_code == 201\n        task = response.json()\n        assert task["title"] == "New Task"\n        assert task["description"] == "Task description"\n        assert task["completed"] is False\n        assert "id" in task\n        assert "created_at" in task\n        assert "updated_at" in task\n\n    def test_post_task_invalid_empty_title(self, client):\n        """Test POST /api/tasks with empty title"""\n        response = client.post("/api/tasks", json={\n            "title": "",\n            "description": "Description"\n        })\n        \n        assert response.status_code == 422\n\n    def test_post_task_invalid_whitespace_title(self, client):\n        """Test POST /api/tasks with whitespace-only title"""\n        response = client.post("/api/tasks", json={\n            "title": "   ",\n            "description": "Description"\n        })\n        \n        assert response.status_code == 422\n\n    def test_post_task_title_too_long(self, client):\n        """Test POST /api/tasks with title exceeding 200 characters"""\n        long_title = "a" * 201\n        response = client.post("/api/tasks", json={\n            "title": long_title,\n            "description": "Description"\n        })\n        \n        assert response.status_code == 422\n\n    def test_post_task_description_too_long(self, client):\n        """Test POST /api/tasks with description exceeding 1000 characters"""\n        long_description = "a" * 1001\n        response = client.post("/api/tasks", json={\n            "title": "Valid Title",\n            "description": long_description\n        })\n        \n        assert response.status_code == 422\n\n    def test_get_task_by_id_existing(self, client):\n        """Test GET /api/tasks/{id} with existing task"""\n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": "Test Task",\n            "description": "Test Description"\n        })\n        task_id = create_response.json()["id"]\n        \n        # Get the task\n        response = client.get(f"/api/tasks/{task_id}")\n        assert response.status_code == 200\n        task = response.json()\n        assert task["id"] == task_id\n        assert task["title"] == "Test Task"\n        assert task["description"] == "Test Description"\n\n    def test_get_task_by_id_non_existent(self, client):\n        """Test GET /api/tasks/{id} with non-existent ID"""\n        fake_id = "00000000-0000-0000-0000-000000000000"\n        response = client.get(f"/api/tasks/{fake_id}")\n        \n        assert response.status_code == 404\n\n    def test_put_task_valid_data(self, client):\n        """Test PUT /api/tasks/{id} with valid data"""\n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": "Original Title",\n            "description": "Original Description"\n        })\n        task_id = create_response.json()["id"]\n        \n        # Update the task\n        response = client.put(f"/api/tasks/{task_id}", json={\n            "title": "Updated Title",\n            "description": "Updated Description",\n            "completed": True\n        })\n        \n        assert response.status_code == 200\n        task = response.json()\n        assert task["id"] == task_id\n        assert task["title"] == "Updated Title"\n        assert task["description"] == "Updated Description"\n        assert task["completed"] is True\n\n    def test_put_task_partial_update(self, client):\n        """Test PUT /api/tasks/{id} with partial data"""\n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": "Original Title",\n            "description": "Original Description"\n        })\n        task_id = create_response.json()["id"]\n        \n        # Update only the title\n        response = client.put(f"/api/tasks/{task_id}", json={\n            "title": "Updated Title"\n        })\n        \n        assert response.status_code == 200\n        task = response.json()\n        assert task["title"] == "Updated Title"\n        assert task["description"] == "Original Description"\n\n    def test_put_task_invalid_empty_title(self, client):\n        """Test PUT /api/tasks/{id} with empty title"""\n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": "Original Title",\n            "description": "Original Description"\n        })\n        task_id = create_response.json()["id"]\n        \n        # Attempt to update with empty title\n        response = client.put(f"/api/tasks/{task_id}", json={\n            "title": ""\n        })\n        \n        assert response.status_code == 422\n\n    def test_put_task_non_existent(self, client):\n        """Test PUT /api/tasks/{id} with non-existent ID"""\n        fake_id = "00000000-0000-0000-0000-000000000000"\n        response = client.put(f"/api/tasks/{fake_id}", json={\n            "title": "Updated Title"\n        })\n        \n        assert response.status_code == 404\n\n    def test_delete_task_existing(self, client):\n        """Test DELETE /api/tasks/{id} with existing task"""\n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": "Task to Delete",\n            "description": "Will be deleted"\n        })\n        task_id = create_response.json()["id"]\n        \n        # Delete the task\n        response = client.delete(f"/api/tasks/{task_id}")\n        assert response.status_code == 204\n        \n        # Verify task is deleted\n        get_response = client.get(f"/api/tasks/{task_id}")\n        assert get_response.status_code == 404\n\n    def test_delete_task_non_existent(self, client):\n        """Test DELETE /api/tasks/{id} with non-existent ID"""\n        fake_id = "00000000-0000-0000-0000-000000000000"\n        response = client.delete(f"/api/tasks/{fake_id}")\n        \n        assert response.status_code == 404\n\n    def test_task_404_responses(self, client):\n        """Test that 404 responses are returned for non-existent tasks"""\n        fake_id = "00000000-0000-0000-0000-000000000000"\n        \n        # GET should return 404\n        get_response = client.get(f"/api/tasks/{fake_id}")\n        assert get_response.status_code == 404\n        \n        # PUT should return 404\n        put_response = client.put(f"/api/tasks/{fake_id}", json={"title": "Test"})\n        assert put_response.status_code == 404\n        \n        # DELETE should return 404\n        delete_response = client.delete(f"/api/tasks/{fake_id}")\n        assert delete_response.status_code == 404\n\n    @given(\n        st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),  # original title\n        st.text(max_size=1000),  # original description\n        st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),  # updated title\n        st.text(max_size=1000)  # updated description\n    )\n    @settings(max_examples=100, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_update_preserves_identity(self, client, original_title, original_description, updated_title, updated_description):\n        """\n        **Feature: task-manager-app, Property 6: Update preserves identity**\n        **Validates: Requirements 5.2, 5.4**\n        \n        For any existing task, when updating its title or description, the task's ID\n        and creation timestamp should remain unchanged, while the updated_at timestamp\n        should be more recent.\n        """\n        import time\n        \n        # Clear all existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Ensure titles don't exceed 200 chars after stripping\n        trimmed_original_title = original_title.strip()[:200]\n        trimmed_updated_title = updated_title.strip()[:200]\n        \n        # Create a task\n        create_response = client.post("/api/tasks", json={\n            "title": trimmed_original_title,\n            "description": original_description\n        })\n        assert create_response.status_code == 201\n        original_task = create_response.json()\n        task_id = original_task["id"]\n        original_created_at = original_task["created_at"]\n        original_updated_at = original_task["updated_at"]\n        \n        # Small delay to ensure updated_at will be different\n        time.sleep(0.01)\n        \n        # Update the task\n        update_response = client.put(f"/api/tasks/{task_id}", json={\n            "title": trimmed_updated_title,\n            "description": updated_description\n        })\n        assert update_response.status_code == 200\n        updated_task = update_response.json()\n        \n        # Verify ID remains unchanged\n        assert updated_task["id"] == task_id\n        \n        # Verify created_at remains unchanged\n        assert updated_task["created_at"] == original_created_at\n        \n        # Verify updated_at is more recent (or at least not earlier)\n        assert updated_task["updated_at"] >= original_updated_at\n        \n        # Verify the update was actually applied\n        assert updated_task["title"] == trimmed_updated_title\n        assert updated_task["description"] == updated_description\n        \n        # Verify persistence by retrieving the task again\n        verify_response = client.get(f"/api/tasks/{task_id}")\n        assert verify_response.status_code == 200\n        persisted_task = verify_response.json()\n        \n        # Verify all identity properties are preserved in persisted data\n        assert persisted_task["id"] == task_id\n        assert persisted_task["created_at"] == original_created_at\n        assert persisted_task["updated_at"] >= original_updated_at\n        assert persisted_task["title"] == trimmed_updated_title\n        assert persisted_task["description"] == updated_description\n\n\nclass TestDeleteAllTasksEndpoint:\n    """Unit tests for DELETE /api/tasks endpoint (bulk deletion)"""\n\n    def test_delete_all_tasks_returns_204(self, client):\n        """Test DELETE /api/tasks returns 204 No Content"""\n        # Create some tasks first\n        client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        client.post("/api/tasks", json={"title": "Task 2", "description": "Desc 2"})\n        \n        # Delete all tasks\n        response = client.delete("/api/tasks")\n        \n        assert response.status_code == 204\n\n    def test_delete_all_tasks_empties_list(self, client):\n        """Test DELETE /api/tasks removes all tasks from the list"""\n        # Create some tasks\n        client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        client.post("/api/tasks", json={"title": "Task 2", "description": "Desc 2"})\n        client.post("/api/tasks", json={"title": "Task 3", "description": "Desc 3"})\n        \n        # Verify tasks exist\n        before_response = client.get("/api/tasks")\n        assert len(before_response.json()["tasks"]) == 3\n        \n        # Delete all tasks\n        response = client.delete("/api/tasks")\n        assert response.status_code == 204\n        \n        # Verify all tasks are deleted\n        after_response = client.get("/api/tasks")\n        assert len(after_response.json()["tasks"]) == 0\n\n    def test_delete_all_tasks_on_empty_list_returns_204(self, client):\n        """Test DELETE /api/tasks on empty list returns 204"""\n        # Clear all existing tasks\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Verify list is empty\n        before_response = client.get("/api/tasks")\n        assert len(before_response.json()["tasks"]) == 0\n        \n        # Delete all tasks (should succeed even on empty list)\n        response = client.delete("/api/tasks")\n        assert response.status_code == 204\n        \n        # Verify list is still empty\n        after_response = client.get("/api/tasks")\n        assert len(after_response.json()["tasks"]) == 0\n\n    def test_delete_all_tasks_has_no_response_body(self, client):\n        """Test DELETE /api/tasks returns no response body"""\n        # Create a task\n        client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        \n        # Delete all tasks\n        response = client.delete("/api/tasks")\n        \n        assert response.status_code == 204\n        assert response.text == "" or response.content == b""\n\n    def test_delete_all_tasks_persists_empty_state(self, client):\n        """Test DELETE /api/tasks persists the empty state"""\n        # Create some tasks\n        client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        client.post("/api/tasks", json={"title": "Task 2", "description": "Desc 2"})\n        \n        # Delete all tasks\n        response = client.delete("/api/tasks")\n        assert response.status_code == 204\n        \n        # Verify tasks remain deleted after multiple GET requests\n        for _ in range(3):\n            verify_response = client.get("/api/tasks")\n            assert len(verify_response.json()["tasks"]) == 0\n\n    def test_delete_all_tasks_allows_new_tasks_after(self, client):\n        """Test that new tasks can be created after DELETE /api/tasks"""\n        # Create some tasks\n        client.post("/api/tasks", json={"title": "Task 1", "description": "Desc 1"})\n        \n        # Delete all tasks\n        response = client.delete("/api/tasks")\n        assert response.status_code == 204\n        \n        # Verify tasks are deleted\n        after_delete_response = client.get("/api/tasks")\n        assert len(after_delete_response.json()["tasks"]) == 0\n        \n        # Create new tasks after deletion\n        create_response = client.post("/api/tasks", json={\n            "title": "New Task After Delete",\n            "description": "This should work"\n        })\n        assert create_response.status_code == 201\n        \n        # Verify new task exists\n        final_response = client.get("/api/tasks")\n        tasks = final_response.json()["tasks"]\n        assert len(tasks) == 1\n        assert tasks[0]["title"] == "New Task After Delete"\n\n    @given(st.lists(\n        st.tuples(\n            st.text(min_size=1, max_size=200).filter(lambda s: s.strip()),\n            st.text(max_size=1000)\n        ),\n        min_size=1,\n        max_size=15\n    ))\n    @settings(max_examples=50, suppress_health_check=[HealthCheck.function_scoped_fixture])\n    def test_property_delete_all_removes_all_tasks(self, client, task_data_list):\n        """\n        Property: For any set of tasks in the system, calling DELETE /api/tasks\n        should result in an empty task list.\n        """\n        # Clear existing tasks first\n        existing_response = client.get("/api/tasks")\n        for task in existing_response.json()["tasks"]:\n            client.delete(f"/api/tasks/{task['id']}")\n        \n        # Create all tasks\n        for title, description in task_data_list:\n            client.post("/api/tasks", json={\n                "title": title.strip(),\n                "description": description\n            })\n        \n        # Verify tasks were created\n        before_response = client.get("/api/tasks")\n        assert len(before_response.json()["tasks"]) > 0\n        \n        # Delete all tasks\n        delete_response = client.delete("/api/tasks")\n        assert delete_response.status_code == 204\n        \n        # Verify all tasks are removed\n        after_response = client.get("/api/tasks")\n        assert len(after_response.json()["tasks"]) == 0\n