"""FastAPI Backend Application

A comprehensive FastAPI application with:
- Health check endpoint
- RESTful API examples
- Request validation with Pydantic models
- Error handling
- CORS middleware
- API documentation (auto-generated by FastAPI)
"""

from fastapi import FastAPI, HTTPException, status, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime
import uvicorn

# Initialize FastAPI app
app = FastAPI(
    title="AB SDLC Agent AI Backend",
    description="Backend API for AB SDLC Agent AI system",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify actual origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================================
# Pydantic Models
# ============================================================================

class HealthResponse(BaseModel):
    """Health check response model"""
    status: str = Field(..., description="Service status")
    timestamp: str = Field(..., description="Current timestamp")
    version: str = Field(..., description="API version")


class Item(BaseModel):
    """Item model for demonstration"""
    id: Optional[int] = Field(None, description="Item ID")
    name: str = Field(..., min_length=1, max_length=100, description="Item name")
    description: Optional[str] = Field(None, max_length=500, description="Item description")
    price: float = Field(..., gt=0, description="Item price (must be positive)")
    in_stock: bool = Field(True, description="Item availability")
    tags: List[str] = Field(default_factory=list, description="Item tags")
    
    @validator('price')
    def validate_price(cls, v):
        """Validate price has max 2 decimal places"""
        if round(v, 2) != v:
            raise ValueError('Price must have at most 2 decimal places')
        return v

    class Config:
        schema_extra = {
            "example": {
                "name": "Laptop",
                "description": "High-performance laptop",
                "price": 999.99,
                "in_stock": True,
                "tags": ["electronics", "computers"]
            }
        }


class ItemUpdate(BaseModel):
    """Item update model - all fields optional"""
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    price: Optional[float] = Field(None, gt=0)
    in_stock: Optional[bool] = None
    tags: Optional[List[str]] = None


class ErrorResponse(BaseModel):
    """Error response model"""
    detail: str = Field(..., description="Error message")
    timestamp: str = Field(..., description="Error timestamp")


# ============================================================================
# In-Memory Data Store (for demonstration)
# ============================================================================

items_db: dict = {
    1: Item(id=1, name="Laptop", description="High-performance laptop", price=999.99, in_stock=True, tags=["electronics"]),
    2: Item(id=2, name="Mouse", description="Wireless mouse", price=29.99, in_stock=True, tags=["electronics", "accessories"]),
    3: Item(id=3, name="Keyboard", description="Mechanical keyboard", price=149.99, in_stock=False, tags=["electronics", "accessories"])
}
next_id = 4


# ============================================================================
# Exception Handlers
# ============================================================================

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    """Custom HTTP exception handler"""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            detail=str(exc.detail),
            timestamp=datetime.utcnow().isoformat()
        ).dict()
    )


@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """General exception handler for unexpected errors"""
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=ErrorResponse(
            detail="Internal server error occurred",
            timestamp=datetime.utcnow().isoformat()
        ).dict()
    )


# ============================================================================
# API Endpoints
# ============================================================================

@app.get("/", tags=["Root"])
async def root():
    """Root endpoint"""
    return {
        "message": "Welcome to AB SDLC Agent AI Backend",
        "documentation": "/docs",
        "alternative_docs": "/redoc"
    }


@app.get(
    "/health",
    response_model=HealthResponse,
    tags=["Health"],
    summary="Health check endpoint"
)
async def health_check():
    """Check the health status of the API"""
    return HealthResponse(
        status="healthy",
        timestamp=datetime.utcnow().isoformat(),
        version="1.0.0"
    )


@app.get(
    "/items",
    response_model=List[Item],
    tags=["Items"],
    summary="Get all items"
)
async def get_items(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(10, ge=1, le=100, description="Maximum number of items to return"),
    in_stock: Optional[bool] = Query(None, description="Filter by stock availability")
):
    """Retrieve all items with optional filtering and pagination"""
    items = list(items_db.values())
    
    # Apply filter if specified
    if in_stock is not None:
        items = [item for item in items if item.in_stock == in_stock]
    
    # Apply pagination
    return items[skip:skip + limit]


@app.get(
    "/items/{item_id}",
    response_model=Item,
    tags=["Items"],
    summary="Get item by ID"
)
async def get_item(item_id: int):
    """Retrieve a specific item by ID"""
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found"
        )
    return items_db[item_id]


@app.post(
    "/items",
    response_model=Item,
    status_code=status.HTTP_201_CREATED,
    tags=["Items"],
    summary="Create a new item"
)
async def create_item(item: Item):
    """Create a new item"""
    global next_id
    
    # Assign new ID
    item.id = next_id
    items_db[next_id] = item
    next_id += 1
    
    return item


@app.put(
    "/items/{item_id}",
    response_model=Item,
    tags=["Items"],
    summary="Update an existing item"
)
async def update_item(item_id: int, item_update: ItemUpdate):
    """Update an existing item completely"""
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found"
        )
    
    # Get existing item
    existing_item = items_db[item_id]
    
    # Update only provided fields
    update_data = item_update.dict(exclude_unset=True)
    updated_item = existing_item.copy(update=update_data)
    
    items_db[item_id] = updated_item
    return updated_item


@app.patch(
    "/items/{item_id}",
    response_model=Item,
    tags=["Items"],
    summary="Partially update an item"
)
async def patch_item(item_id: int, item_update: ItemUpdate):
    """Partially update an existing item"""
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found"
        )
    
    # Get existing item
    existing_item = items_db[item_id]
    
    # Update only provided fields
    update_data = item_update.dict(exclude_unset=True)
    updated_item = existing_item.copy(update=update_data)
    
    items_db[item_id] = updated_item
    return updated_item


@app.delete(
    "/items/{item_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    tags=["Items"],
    summary="Delete an item"
)
async def delete_item(item_id: int):
    """Delete an item by ID"""
    if item_id not in items_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Item with id {item_id} not found"
        )
    
    del items_db[item_id]
    return None


@app.get(
    "/items/search/by-name",
    response_model=List[Item],
    tags=["Items"],
    summary="Search items by name"
)
async def search_items(
    query: str = Query(..., min_length=1, description="Search query")
):
    """Search for items by name (case-insensitive partial match)"""
    query_lower = query.lower()
    results = [
        item for item in items_db.values()
        if query_lower in item.name.lower()
    ]
    return results


# ============================================================================
# Startup and Shutdown Events
# ============================================================================

@app.on_event("startup")
async def startup_event():
    """Execute on application startup"""
    print("="* 60)
    print("AB SDLC Agent AI Backend - Starting up...")
    print(f"API Documentation available at: http://localhost:8000/docs")
    print(f"Alternative docs available at: http://localhost:8000/redoc")
    print("="* 60)


@app.on_event("shutdown")
async def shutdown_event():
    """Execute on application shutdown"""
    print("="* 60)
    print("AB SDLC Agent AI Backend - Shutting down...")
    print("="* 60)


# ============================================================================
# Main Entry Point
# ============================================================================

if __name__ == "__main__":
    # Run the application with uvicorn
    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=8000,
        reload=True,  # Enable auto-reload during development
        log_level="info"
    )
